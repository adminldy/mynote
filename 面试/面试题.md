### Taptap
#### 一、 TCP三次握手

<b>第一次握手</b>:

客户端发送syn包（Seq=x）到服务器，并进入SYN_SEND，等待服务器确认

<b>第二次握手</b>:

服务器收到syn包，必须确认客户的SYN (ack=x+1), 同时自己也发送一个SYN包(seq=y), 即SYN+ACK包，此时服务器进入SYN_RECV

<b>第三次握手</b>:

客户端收到服务器的SYN+ACK包， 向服务器发送确认包ACK(ack=y+1), 此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手

为什么会采用三次握手，采用两次可以吗， 四次呢？

采用三次握手是为了防止失效得连接请求报文段突然又传送到主机B， 因而产生错误，假如主机A发送得连接请求没有到达主机B
主机A就会重新发送请求，然后主机B发送确认 建立了连接 而这时主机A第一次发送得请求因为延迟原因到了主机B 主机B以为又建立
起了新的连接 而主机A这时就不理会主机B了 主机B会一直等， 导致资源得浪费

三次握手就确保了双方得通信能力， 四次就没必要了

#### 二、http1.0 1.1 1.2都有哪些区别

1. http1.0: 每进行一次HTTP通信， 都需要经历建立TCP连接、 传输HTTP数据和断开TCP连接三个阶段

2. http1.1优化:
   2.1 增加了持久连接
   2.2 浏览器为每个域名最多同时维护6个TCP持久连接
   2.3 使用CDN得实现分片机制

注： 每个TCP需要维护6个连接

存在的问题:

第一个原因, TCP的慢启动

一旦一个TCP连接建立之后， 就进入了发送状态，刚开始TCP协议会采用一个非常慢的速度去发送数据， 然后慢慢加快发送数据的速度，
直至发送数据的速度达到一个理想状态，我们把这个过程称为慢启动

第二个原因， 同时开启了多条TCP连接， 那么这些连接会竞争固定的带宽

第三个原因， 队头阻塞

在http1.1中使用持久连接，虽然能公用一个TCP管道， 但是在一个管道中同一时刻只能处理一个请求， 在当前的请求没有结束之前，
其他的请求只能处于阻塞状态， 假如有得请求被阻塞了5秒， 那么HTT后续排队都要延迟等待5秒

3. http2改进

总结：一个域名只使用一个TCP连接和消除队头阻塞问题

多路复用机制:

HTTP/2添加了一个二进制分帧层

* 首先，浏览器准备好请求数据
* 这些数据经过二进制分帧层之后， 会被转换为一个个带有请求ID编号的帧， 通过协议栈将这些帧发送给服务器
* 服务器接收到所有帧之后，会将所有相同的ID的帧合并为一条完整的请求信息
* 然后服务器处理该条请求， 并将处理的响应行、响应头和响应体分别发送至二进制分帧层
* 同样二进制分帧层会将这些响应数据转换为一个个带有请求ID编号的帧，经过协议栈发送给浏览器
* 浏览器接收到响应帧之后， 会根据ID编号将帧的数据提交给对应的请求

HTTP2其他特性
1. 服务器推送：
还可以将数据提前推送到浏览器，当用户请求一个HTML⻚面之后，服务器知道该HTML⻚面会引用几个重要的JavaScript文件和CSS文件，那么在 接收到HTML请求之后，附带将要使用的CSS文件和JavaScript文件一并发送给浏览器.

2. 头部压缩

将请求头和响应头进行了压缩

#### 三、给你一个已经升序排列的数组，给一个数字，找一下这个数字在这个数组里出现了几次

算法 2. 升序arr.js

#### 四、洗牌算法

